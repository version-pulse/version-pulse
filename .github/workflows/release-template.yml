# .github/workflows/release-template.yml
name: Generate Release Note

on:
  workflow_call:
    inputs:
      pr_number:
        required: true
        type: number
      tag_name:
        required: true
        type: string
    outputs:
      release_note:
        description: 'Generated release note'
        value: ${{ jobs.generate.outputs.release_note }}

jobs:
  generate:
    runs-on: ubuntu-latest
    outputs:
      release_note: ${{ steps.generate.outputs.result }}
    steps:
      - name: Checkout
        uses: actions/checkout@v4

      - name: Generate Release Notes
        id: generate
        uses: actions/github-script@v7
        with:
          script: |
            const prNumber = ${{ inputs.pr_number }};
            const { data: commits } = await github.rest.pulls.listCommits({
              owner: context.repo.owner,
              repo: context.repo.repo,
              pull_number: prNumber
            });

            let commitMessages = commits.map(commit => commit.commit.message);

            const categories = {
              feat: [],
              fix: [],
              refactor: [],
              docs: [],
              chore: [],
              deploy: [],
              test: [],
              other: []
            };

            commitMessages.forEach(message => {
              if (/.*Feat[:\s]/.test(message)) {
                categories.feat.push(message);
              } else if (/.*Fix[:\s]/.test(message)) {
                categories.fix.push(message);
              } else if (/.*Refac[:\s]/.test(message)) {
                categories.refactor.push(message);
              } else if (/.*Docs[:\s]/.test(message)) {
                categories.docs.push(message);
              } else if (/.*Chore[:\s]/.test(message)) {
                categories.chore.push(message);
              } else if (/.*Deploy[:\s]/.test(message)) {
                categories.deploy.push(message);
              } else if (/.*Test[:\s]/.test(message)) {
                categories.test.push(message);
              } else {
                categories.other.push(message);
              }
            });

            let releaseNote = `## ðŸš€ version-pulse ${{ inputs.tag_name }} (${new Date().toISOString().split('T')[0]})\n`;
            releaseNote += `ì´ë²ˆ ë¦´ë¦¬ì¦ˆì—ì„œëŠ” ì£¼ìš” ê¸°ëŠ¥ ì¶”ê°€ ë° ê°œì„  ì‚¬í•­ì´ í¬í•¨ë˜ì–´ ìžˆìŠµë‹ˆë‹¤.\n\n`;

            if (categories.fix.length > 0) {
              releaseNote += `ðŸ› ë²„ê·¸ ìˆ˜ì • (Bug Fixes)\n`;
              categories.fix.forEach(item => releaseNote += `- ${item.replace(/^Fix:\s*/, '')}\n`);
              releaseNote += '\n';
            }

            if (categories.refactor.length > 0) {
              releaseNote += `ðŸ›  ë¦¬íŒ©í† ë§ ë° ê°œì„  (Refactoring & Improvements)\n`;
              categories.refactor.forEach(item => releaseNote += `- ${item.replace(/^Refac:\s*/, '')}\n`);
              releaseNote += '\n';
            }

            if (categories.feat.length > 0) {
              releaseNote += `âœ¨ ìƒˆë¡œìš´ ê¸°ëŠ¥ (New Features)\n`;
              categories.feat.forEach(item => releaseNote += `- ${item.replace(/^Feat:\s*/, '')}\n`);
              releaseNote += '\n';
            }

            if (categories.docs.length > 0 || categories.chore.length > 0 || categories.deploy.length > 0) {
              releaseNote += `âš™ï¸ ë¹Œë“œ ë° ë°°í¬ ê´€ë ¨ (Build & Deployment)\n`;
              [...categories.docs, ...categories.chore, ...categories.deploy].forEach(item => releaseNote += `- ${item.replace(/^(Docs|Chore|Deploy):\s*/, '')}\n`);
              releaseNote += '\n';
            }

            if (categories.other.length > 0) {
              releaseNote += `ðŸ”¹ ê¸°íƒ€ ë³€ê²½ ì‚¬í•­\n`;
              categories.other.forEach(item => releaseNote += `- ${item}\n`);
              releaseNote += '\n';
            }

            console.log("âœ… Generated Release Note:\n" + releaseNote);
            return releaseNote.replace(/\r?\n/g, '%0A');
